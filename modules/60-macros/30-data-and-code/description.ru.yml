---

name: Данные как код
theory: |
  Когда речь заходит о Lisp-подобных языках, часто упоминается фраза "код как данные", разберемся, что же она означает и как эта фраза связана с макросами (об этом немного говорилось в теме Списки).

  Рассмотрим примеры Clojure кода и Python (немножко разнообразия никогда не помешает!):

  ```python
  def func(foo):
    return do_something(foo)
  ```

  В Clojure аналогичный код будет выглядеть так:

  ```clojure
  (defn func [foo]
    (do-something foo))
  ```

  Синтаксис очень похож, разница лишь в том, что код на Clojure записывается внутри *списка*. Lisp-подобные языки не различают выражения `(func arg1 arg2)` и `(1 2 3)`. Рассмотрим это на примере:

  ```clojure
  ; Нет необходимости даже объявлять func, arg1 и arg2
  ; про символ ' будет описано чуть позже
  (count '(func arg1 arg2))
  ; => 3

  (count '(1 2 3))
  ; => 3
  ```

  Однако в Python так сделать нельзя:

  ```python
  len(func(arg1, arg2))
  Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  NameError: name 'func' is not defined
  ```

  А какая здесь связь с макросами? Если описывать упрощенно, то макросы создают валидные lisp формы для их выполнения (evaluation). Макросы можно воспринимать как lisp трансляторы: вы передаете какие-то данные и макрос переводит эти данные уже в валидные lisp данные (которые как код можно выполнить).

  Теперь переключимся на символ `'`, который мы использовали в коде выше. Зачем он нужен? В Lisp-подобных языках есть такие понятия как *символ* (symbol) и *значение* (value) и очень важно понимать, в чем между ними разница. Например:

  ```python
  foo = 10
  ```

  В таком коде мы размышляем о переменной `foo` как о `10`, грубо говоря, мы думаем о *значении*, а не о *символе* `foo`, которое оно представляет. В Clojure же (и во всех Lisp-подобных языках) ситуация другая. Язык позволяет ссылаться на *символ* не затрагивая его *значения*. В большинстве других языков такое невозможно. То есть если вы хотите сослаться на символ (эта тема уже затрагивалась в модуле со списками), нужно воспользоваться `'` (мы еще вернемся к теме символов). А теперь рассмотрим пример:

  ```clojure
  (def foo 10)
  ; мы объявили символ и его значение

  ; ссылаемся на значение символа
  foo
  ; => 10

  ; ссылаемся на символ
  'foo
  ; => foo
  ```

  Итак, после такой долгой подготовки напишем простенький макрос! В Lisp-подобных языках используется префиксная нотация, создадим макрос, который позволит записывать простые операции инфиксной нотацией, например `(2 + 2)`. В наш макрос передается список из трех элементов (да, `+` тоже является элементом списка). Затем нам нужно переставить переданные данные в валидное lisp выражение, то есть мы хотим получить такой эффект `(1 + 2) -> (+ 1 2)`. Как можно получить такое выражение? Всего лишь передвинуть второй элемент списка в начало!

  ```clojure
  (defmacro infix-notation [[left operator right]]
    (list operator left right))

  (infix-notation (1 + 2))
  ; => 3

  (infix-notation (1 > 2))
  ; => false
  ```

  `(1 + 2)` и `(1 > 2)` не являются валидным lisp кодом, но наш макрос позволяет перевести его в `(+ 1 2)` и `(> 1 2)` соответственно, а эти выражения уже являются корректным lisp кодом, который можно выполнить.

instructions: |
  Для закрепления, создайте макрос `postfix-notation`, который позволяет выполнять такой код `(2 2 +)` (то есть позволяет записывать формы постфиксной нотацией).

tips:
  - |
    [Модуль по спискам](https://ru.code-basics.com/languages/clojure/lessons/intro)
  - |
    [Статья о символе '](https://8thlight.com/blog/colin-jones/2012/05/22/quoting-without-confusion.html)
