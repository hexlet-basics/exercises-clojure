---

name: Правила макросов
theory: |
  Теперь посмотрим, как выполняется код внутри макросов:

  ```clojure
  (defmacro id-mac [x]
    "Hello, macro!"
    x)

  (macroexpand-1 '(id-mac (println "str")))
  ; => (println "str")
  ```

  Как видно из примера, строка, `"Hello, macro!"` нигде не появилась, следовательно, как и в обычной функции, возвращается последняя форма. Вспомним макрос из прошлого упражнения:

  ```clojure
  (defmacro identity-macro [x]
    (println "identity of x")
    x)
  ```

  Как мы уже выяснили, когда мы вызываем `identity-macro`, форма `(println "identity of x")` вызывается до возвращения последней формы, что еще раз подтверждает, что тело макроса выполняется так же как и в обычной функции. Это будет вторым правилом макросов: Тело макросов выполняется в соответствии с обычными правилами Clojure.

  Посмотрим еще несколько функций и макросов:

  ```clojure
  (defn triplet-fn [a b c]
    (list a b c))

  (defmacro triplet-macro [a b c]
    (list a b c))

  (triplet-fn 1 2 3)
  ; => (1 2 3)

  (triplet-macro 1 2 3)
  ; => java.lang.Exception: Cannot call 1 as a function.

  ; Что-то пошло не так, посмотрим, во что макрос разворачивается

  (macroexpand '(triplet-macro 1 2 3))
  ; => (1 2 3)

  ; Хм, кажется все начинает сходиться, попробуем вызвать макрос напрямую
  (eval (macroexpand '(triplet-macro 1 2 3)))
  ; => java.lang.Exception: Cannot call 1 as a function.

  ; Ошибка такая же, как и в примере выше, Clojure пытается
  ; выполнить код (1 2 3), который не является валидной формой
  ```

  Пора подводить итоги! Из примера выше можно сформировать еще одно, третье правило макросов: Данные, возвращаемые макросом немедленно исполняются и результат этого выполнения отдается наружу (третье правило не совсем корректно, но для нынешнего понимания этого пока что достаточно). Полезно помнить, что возвращаемая форма выполняется дважды, когда вы пишете макрос и единожды, когда пишете обычную функцию. Теперь вспомним еще раз все правила, которые сформулировали:

  - Аргументы не выполняются перед тем, как были отправлены в тело макроса;
  - Тело макросов выполняется в соответствии с обычными правилами Clojure;
  - Данные, возвращаемые макросом немедленно исполняются и результат этого выполнения отдается наружу.

instructions: |
  Исправьте `triplet-macro`, чтобы он работал так же, как и `triplet-fn` (не забывайте третье правило макросов!). Затем выведите результат (с помощью `println`) для следующих аргументов:

  - 1, 2, 3
  - -1, -2, -3

tips: []
