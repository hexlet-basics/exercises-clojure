---

name: Порядок вычисления
theory: |
  Попробуем превратить выражение `5 - 3 + 1` в программу на Clojure. С точки зрения арифметики, порядок вычисления элементов этого составного выражения строго определен. Сначала вычисляется `5 - 3`, затем к получившемуся результату прибавляется единица.

  Начнем с того, что вычисляется первым: `5 - 3` превращается в `(- 5  3)`. Затем сложим получившийся результат с единицей: `(+ (- 5 3) 1)`. Так как сложение — это коммутативная операция (помните "от перемены мест слагаемых сумма не меняется"?), то же самое можно записать и в другом порядке: `(+ 1 (- 5 3))`. Неизменным остается то, что в начале каждого списка находится операция.

  Заметьте, выражения, вычисляемые первыми, находятся в глубине дерева. Такое поведение свойственно большинству обычных языков. Сначала вычисляются аргументы функций, затем вызывается сама функция.

  Попробуем другой вариант: `5 - (3 + 1)`. В этом выражении скобки устанавливают другой приоритет. Это значит, что сначала вычислится сумма единицы и тройки. Так и запишем `(+ 3 1)` (или так `(+ 1 3)`). Теперь возьмём пятерку и вычтем из неё получившийся результат: `(- 5 (+ 1 3))`.

  В такие моменты проявляется ещё одна отличительная особенность Lisp-языков. Древовидная структура программы сама определяет последовательность вычисления поддеревьев. Отпадает необходимость использовать дополнительные скобки.

  Ещё один пример: `5 + 7 + (8 - 3) - (8 * 5)`. Действуем по привычной схеме:
  * `(* 5 8)`
  * `(- 8 3)`
  * `(+ 5 7 (- 8 3))`
  * `(- (+ 5 7 (- 8 3)) (* 5 8))`

  В некоторых ситуациях порядок вычисления элементов списка не соответствует порядку их следования. Такое происходит при использовании специальных форм и макросов. Об этом поговорим позже.

instructions: |
  Выведите в стандартный поток вывода (с помощью функции `println`) следующее выражение: `100 - 34 - 22 - (5 + 3 - 10)`

tips: []
