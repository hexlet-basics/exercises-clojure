Когда речь заходит о Lisp-подобных языках, часто упоминается фраза "код как данные", разберемся, что же она означает и как эта фраза связана с макросами (об этом немного говорилось в теме Списки).

Рассмотрим примеры Clojure кода и Python (немножко разнообразия никогда не помешает!):

```python
def func(foo):
  return do_something(foo)
```

В Clojure аналогичный код будет выглядеть так:

```clojure
(defn func [foo]
  (do-something foo))
```

Синтаксис очень похож, разница лишь в том, что код на Clojure записывается внутри *списка*. Lisp-подобные языки не различают выражения `(func arg1 arg2)` и `(1 2 3)`. Рассмотрим это на примере:

```clojure
; Нет необходимости даже объявлять func, arg1 и arg2
; про символ ' будет описано чуть позже
(count '(func arg1 arg2))
; => 3

(count '(1 2 3))
; => 3
```

Однако в Python так сделать нельзя:

```python
len(func(arg1, arg2))
# Traceback (most recent call last):
# File "<stdin>", line 1, in <module>
# NameError: name 'func' is not defined
```

А какая здесь связь с макросами? Если описывать упрощенно, то макросы создают валидные lisp формы для их выполнения (evaluation). Макросы можно воспринимать как lisp трансляторы: вы передаете какие-то данные и макрос переводит эти данные уже в валидные lisp данные (которые как код можно выполнить).

Теперь переключимся на символ `'`, который мы использовали в коде выше. Зачем он нужен? В Lisp-подобных языках есть такие понятия как *символ* (symbol) и *значение* (value) и очень важно понимать, в чем между ними разница. Например:

```python
foo = 10
```

В таком коде мы размышляем о переменной `foo` как о `10`, грубо говоря, мы думаем о *значении*, а не о *символе* `foo`, которое оно представляет. В Clojure же (и во всех Lisp-подобных языках) ситуация другая. Язык позволяет ссылаться на *символ* не затрагивая его *значения*. В большинстве других языков такое невозможно. То есть если вы хотите сослаться на символ (эта тема уже затрагивалась в модуле со списками), нужно воспользоваться `'` (мы еще вернемся к теме символов). А теперь рассмотрим пример:

```clojure
(def foo 10)
; мы объявили символ и его значение

; ссылаемся на значение символа
foo
; => 10

; ссылаемся на символ
'foo
; => foo
```

Итак, после такой долгой подготовки напишем простенький макрос! В Lisp-подобных языках используется префиксная нотация, создадим макрос, который позволит записывать простые операции инфиксной нотацией, например `(2 + 2)`. В наш макрос передается список из трех элементов (да, `+` тоже является элементом списка). Затем нам нужно переставить переданные данные в валидное lisp выражение, то есть мы хотим получить такой эффект `(1 + 2) -> (+ 1 2)`. Как можно получить такое выражение? Всего лишь передвинуть второй элемент списка в начало!

```clojure
(defmacro infix-notation [[left operator right]]
  (list operator left right))

(infix-notation (1 + 2))
; => 3

(infix-notation (1 > 2))
; => false
```

`(1 + 2)` и `(1 > 2)` не являются валидным lisp кодом, но наш макрос позволяет перевести его в `(+ 1 2)` и `(> 1 2)` соответственно, а эти выражения уже являются корректным lisp кодом, который можно выполнить.
