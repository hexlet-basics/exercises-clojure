---

name: Локальные объявления
theory: |
  `def` в Clojure может использоваться как на уровне модуля, так и внутри функций:

  ```clojure
  (defn f []
    (def text "lorem")
    (println text))
  (f) ; => "lorem"
  ; у `def text` локальная область видимости
  (println text) ; <error>
  ```

  Но с ним связано несколько тонких моментов:

  * Хотя лиспы похожи между собой, конкретно `def` ведет себя совершенно по-разному в разных диалектах Lisp. В некоторых объявления останутся локальными для текущей области видимости, в других же объявление всегда будет глобальным.
  * Объявления переменных должны идти в самом начале функции, до любых других выражений.

  Существует и другой способ объявить локальные переменные, гораздо более популярный и предсказуемый:

  ```clojure
  (let [text "lorem"] (println text)) ; => lorem
  ```

  Каждое объявление в `let` — это список из имени и выражения, вычисленное значение которого будет ассоциировано с именем. Перепишем уже знакомую нам функцию `sum`, используя локальные объявления:

  ```clojure
  ; форма записи без локальных объявлений:
  (def sum (fn [x y] (+ x y)))
  (sum 8 7) ; вызов глобальной функции
  ; форма записи с локальными объявлениями:
  (let [sum (fn [x y] (+ x y))]
    (sum 8 7)) ; вызов локальной функции
  ```

  Все объявления внутри `let` доступны только в выражениях, которые вызываются внутри самого `let` *после списка объявлений*. Вот ещё несколько более сложных примеров, с несколькими объявлениями:

  ```clojure
  (let [x 2
        y (+ 4 3)]
    (+ x y)) ; 9
  ```

  ```clojure
  (defn sum-of-squares [x y]
    (let [x-square (* x x)
          y-square (* y y)]
      (+ x-square y-square)))
  ```

  Можно пойти еще дальше — вызывать локальную функцию внутри глобальной:

  ```clojure
  (defn sum-of-squares [x y]
    (let [square (fn [n] (* n n))]
      (+ (square x) (square y))))
  (sum-of-squares 8 7) ; => 113
  ```

  Объявления, созданные в рамках одного использования `let`, видны друг другу. Поэтому мы можем сделать так:

  ```clojure
  (let [x 2
        y (* x 10)]
    (+ x y))
  ```

  Есть еще форма `letfn`, которая делает то же самое, только для функций, в более коротком виде:

  ```clojure
  (letfn [(increment [x] (+ x 1))
          (decrement [x] (- x 1))
          (put-value [] 10)]
    (increment (decrement (put-value)))); 10
  ```

instructions: |
  Реализуйте функцию `prod-sum`, которая сначала умножает переданное число на себя, а затем суммируется между собой и полученным результатом умножения. Воспользуйтесь локальными объявлениями для хранения промежуточных результатов вычисления.

  ```clojure
  (prod-sum 2) ; 6
  (prod-sum 3) ; 12
  (prod-sum 4) ; 20
  ```

definitions: []
tips:
  - |
    [Официальная документация](https://clojuredocs.org/clojure.core/let)
