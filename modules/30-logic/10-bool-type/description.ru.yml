---

name: Логические операторы
theory: |
  True и False в Clojure представлены значениями `true` и `false` соответственно. Большинство операций в Clojure рассматривают как ложь только `false` и `nil` (отсутствие значения). Все остальное считается истиной. Пара примеров проверки на равенство:

  ```clojure
  (= 42 42) ; true
  (= 42 24) ; false
  ```

  Равенство значений проверяется через функцию `=`. Напишем функцию `gt?`, которая возвращает `true`, если первое число больше второго и `false` в другом случае. В Clojure имена предикатов заканчиваются вопросительным знаком. При этом к ним не добавляется префикс "is".

  ```clojure
  (defn gt? [x y] (> x y))
  (gt? 3 2) ; true
  (gt? 10 15) ; false
  ```

  _Вот так разработчики на Ruby узнали почему в их языке предикаты выглядят как вопросы :)_
  Теперь напишем предикат, определяющий четность числа. Для этого нам понадобится функция `rem`, которая вычисляет остаток от деления.

  ```clojure
  (defn even? [n] (= (rem n 2) 0))
  (even? 3) ; false
  (even? 4) ; true
  ```

  > Строго говоря, такая функция уже есть в языке. Здесь мы её реализуем заново только ради примера.
  Логические операторы в Clojure не имеют символьных обозначений, вместо этого используются функции `and`, `or`, `not` и другие.

  ```clojure
  (not "moon") ; false
  (and (odd? 3) (even? 4)) ; true
  ```

  Как и в случае с арифметическими операциями, мы получаем два бонуса:
  1. Префиксная нотация позволяет комбинировать любое число условий: `(and <one> <two> <three> <...>)`.
  2. Благодаря древовидной структуре исходного кода, приоритет всегда точно определен.

instructions: |
  Реализуйте функцию `leap-year?`, которая проверяет, является ли год високосным. Любой год, который делится на 4 без остатка, является високосным годом. Тем не менее, есть еще небольшая особенность, которая должна быть учтена например, григорианский календарь предусматривает, что год, который делится без остатка на 100 является високосным годом только в том случае, если он также без остатка делится на 400.

  ```clojure
  (leap-year? 2012) ; true
  (leap-year? 1913) ; false
  (leap-year? 1804) ; true
  (leap-year? 2100) ; false
  ```

tips: []
