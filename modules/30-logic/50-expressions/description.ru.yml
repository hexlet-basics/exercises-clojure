---

name: Логические выражения
theory: |
  Во многих языках для того, чтобы внутри вычисляемых выражений использовать логическое ветвление, приходится использовать отдельные специфические варианты конструкции `if` (как это сделано в Python) или же вовсе — использовать отдельные *тернарные операторы*.
  Здесь лиспоподобные языки — и Clojure в частности — обладают одним важным преимуществом: в этих языках всё есть выражение. Поэтому отдельные варианты условных конструкций не нужны, вместо этого можно использовать `if`, `case`, `cond` как часть любого другого выражения! Вот парочка примеров:

  ```clojure
  (println (if true "Ok" "Oops")) ; => Ok
  (println (when false "Ok"))     ; => nil
  ```

  Заметьте, во втором случае условие для `when` было ложным, поэтому всё выражение `when` вычислилось в специальное "пустое" значение, но тем не менее — вычислилось! И функция `println` вывела это значение на экран, пусть даже и в таком своеобразном виде.
  Если помнить об этом свойстве языка, то можно писать довольно таки сложные выражения, не выделяя промежуточные вычисления в переменные:

  ```clojure
  (defn classify [x]
    (cond
      (< x 0) "Negative"
      (case x
         (13 42 100500) true
          false) "Special"
      :else "Boring"))
  ```

  В этом примере используются сильные стороны и `cond` и `case`: первый хорошо справляется с выбором по условию, а второй хорошо проверяет на совпадение с конкретными значениями, выступая при этом в качестве того самого условия для `cond`.
  И, раз уж речь зашла о выносе подвыражений в переменные, то тут у Clojure тоже всё хорошо. В других языках иной раз приходится делать присваивание значений переменным из условной конструкции или обходиться тернарным оператором. В Clojure же можно использовать обычный `let`:

  ```clojure
  (defn classify [x]
    (let [is-special
           (case x
             (13 42 100500) true
             false)]
      (cond
        (< x 0) "Negative"
        is-special "Special"
        :else "Boring")))
  ```

  > Этот вариант читается лучше, чем предыдущий, но имеет один недостаток: значение `is-special` вычисляется в любом случае, тогда как в предыдущем варианте его вычислять не нужно, если выполнилось условие, проверяющее аргумент на отрицательность.

instructions: |
  Реализуйте функцию `do-today`, которая принимает порядковый номер дня недели (целое число) в качестве аргумента и вычисляется в
  - строку `"work"` для дней с понедельника (`1`) по пятницу (`5`),
  - строку `"rest"` для субботы (`6`) и воскресенья (`7`),
  - строку `"???"` для всех остальных значений, в том числе и для нечисловых!
  Попробуйте использовать в решении различные комбинации `if`, `cond` и `case`.

tips:
  - |
    Используйте функцию-предикат `int?` чтобы проверить, что аргумент — целое число.
