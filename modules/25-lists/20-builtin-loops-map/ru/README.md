Любой список рано или поздно захочется *обойти* (*traverse*), то есть поработать с отдельными элементами. В процедурных языках используются циклы, но многие языки имеют и декларативные средства работы с коллекциями — `map`, `filter`, `reduce`. А ведь сами эти функции пришли в программирование через LISP!
Clojure тоже предоставляет полный набор таких функций. Ближайшие несколько уроков будут посвящены этим встроенным в Clojure функциям.

### `map`
Итак, `map` в Clojure используется так:

```clojure
(map inc (list 1 2 3)) ; '(2 3 4)
```

Здесь `inc` — встроенная функция, добавляющая к числу единицу. Всё максимально предсказуемо: `map` превращает старый список в новый, применяя функцию к каждому элементу. Обход получается *функциональный*, потому что мы получаем **новый** список, не меняя старый.
Может `map` обходить и несколько списков одновременно: можно применить `map` к нескольким спискам, тогда функция-аргумент будет применена ко всем первым элементам, затем ко всем вторым, и так далее. Но `map` потребует от входных списков иметь одинаковую длину, иначе вы получите ошибку.
Вот так можно поэлементно просуммировать три списка:

```clojure
(map +
     (list 1 2 3)
     (list 10 20 30)
     (list 100 200 300))
; '(111 222 333)
```

Заметьте, не потребовалось даже использовать анонимную функцию, которая складывала бы три числа, ведь функция "`+`" принимает произвольное количество аргументов!
